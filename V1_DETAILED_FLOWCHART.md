# V1内存池流程图详解

## 一、整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    HashBucket (哈希桶)                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────────────────────────────────────────────┐   │
│  │         useMemory(size) / freeMemory(ptr, size)      │   │
│  │                                                      │   │
│  │   if size > 512:                                     │   │
│  │       → operator new/delete                         │   │
│  │   else:                                              │   │
│  │       → index = (size + 7) / 8 - 1                   │   │
│  │       → memoryPool[index].allocate()/deallocate()    │   │
│  └──────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              MemoryPool[64] 数组                     │   │
│  │                                                      │   │
│  │  [0] 8字节   [1] 16字节  [2] 24字节  ...  [63] 512字节│   │
│  └──────────────────────────────────────────────────────┘   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 二、单个MemoryPool结构

```
┌─────────────────────────────────────────────────────────────┐
│                      MemoryPool                             │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│  │ Block 1     │    │ Block 2     │    │ Block 3     │      │
│  │ ┌─────────┐ │    │ ┌─────────┐ │    │ ┌─────────┐ │      │
│  │ │ Slot*   │ │    │ │ Slot*   │ │    │ │ Slot*   │ │      │
│  │ │ next    │─┼───→│ │ next    │─┼───→│ │ next    │─┼──→   │
│  │ └─────────┘ │    │ └─────────┘ │    │ └─────────┘ │      │
│  │   [Slot1]   │    │   [Slot1]   │    │   [Slot1]   │      │
│  │   [Slot2]   │    │   [Slot2]   │    │   [Slot2]   │      │
│  │   [Slot3]   │    │   [Slot3]   │    │   [Slot3]   │      │
│  │   ...       │    │   ...       │    │   ...       │      │
│  └─────────────┘    └─────────────┘    └─────────────┘      │
│       ↑                  ↑                  ↑               │
│       └──────────────────┴──────────────────┘               │
│                    firstBlock_                               │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  freeList_ (空闲链表) - CAS无锁操作                    │   │
│  │                                                      │   │
│  │   ┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐         │   │
│  │   │ Slot │→  │ Slot │→  │ Slot │→  │ Slot │→ nullptr│   │
│  │   │  A   │   │  B   │   │  C   │   │  D   │         │   │
│  │   └──────┘   └──────┘   └──────┘   └──────┘         │   │
│  │     ↑                                            ↑    │   │
│  │     └────────────────────────────────────────────┘    │   │
│  │                    freeList_ (atomic)                   │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  curSlot_ → 当前未使用的槽                            │   │
│  │  lastSlot_ → 当前块的边界                              │   │
│  │  mutexForBlock_ → 保护块分配                          │   │
│  │  mutexForFreeList_ → 保护freeList_（当前版本）        │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 三、内存分配流程 (allocate)

```
┌─────────────────────────────────────────────────────────────┐
│                    allocate() 流程                          │
└─────────────────────────────────────────────────────────────┘

开始
  ↓
┌───────────────────────────────────────────────────────────┐
│  步骤1: 尝试从freeList_获取内存                            │
│                                                           │
│  Slot* slot = popFreeList()                               │
│                                                           │
│  ┌─────────────────────────────────────────────────────┐  │
│  │  popFreeList() - CAS无锁出队                        │  │
│  │                                                     │  │
│  │  while(true):                                       │  │
│  │    1. oldHead = freeList_.load()                   │  │
│  │    2. if oldHead == nullptr: return nullptr        │  │
│  │    3. newHead = oldHead->next                       │  │
│  │    4. CAS(freeList_, oldHead, newHead)             │  │
│  │       ✓ 成功 → return oldHead                       │  │
│  │       ✗ 失败 → 重试                                  │  │
│  └─────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────┘
  ↓
slot != nullptr?
  ├─ 是 → 返回 slot (分配成功)
  │
  └─ 否 ↓
┌───────────────────────────────────────────────────────────┐
│  步骤2: 从当前Block分配新内存                             │
│                                                           │
│  lock(mutexForBlock_)                                     │
│                                                           │
│  curSlot_ >= lastSlot_?                                   │
│    ├─ 是 → allocateNewBlock() 申请新Block                │
│    └─ 否 → 使用curSlot_                                  │
│                                                           │
│  temp = curSlot_                                          │
│  curSlot_ += SlotSize_ / sizeof(Slot)                     │
│                                                           │
│  unlock(mutexForBlock_)                                   │
└───────────────────────────────────────────────────────────┘
  ↓
返回 temp
  ↓
结束
```

---

## 四、内存释放流程 (deallocate)

```
┌─────────────────────────────────────────────────────────────┐
│                   deallocate(ptr) 流程                      │
└─────────────────────────────────────────────────────────────┘

开始
  ↓
ptr == nullptr?
  ├─ 是 → 直接返回
  │
  └─ 否 ↓
┌───────────────────────────────────────────────────────────┐
│  步骤: 将释放的内存放回freeList_                            │
│                                                           │
│  Slot* slot = reinterpret_cast<Slot*>(ptr)                │
│  pushFreeList(slot)                                       │
│                                                           │
│  ┌─────────────────────────────────────────────────────┐  │
│  │  pushFreeList() - CAS无锁入队                        │  │
│  │                                                     │  │
│  │  while(true):                                       │  │
│  │    1. oldHead = freeList_.load()                   │  │
│  │    2. slot->next = oldHead                         │  │
│  │    3. CAS(freeList_, oldHead, slot)                │  │
│  │       ✓ 成功 → return true                          │  │
│  │       ✗ 失败 → 重试                                  │  │
│  └─────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────┘
  ↓
结束
```

---

## 五、CAS无锁操作详解

### 5.1 pushFreeList CAS流程

```
初始状态：
freeList_ ──→ A ──→ B ──→ C ──→ nullptr

┌───────────────────────────────────────────────────────────┐
│  Thread 1: pushFreeList(slot)                             │
└───────────────────────────────────────────────────────────┘

步骤1: 读取当前头节点
oldHead = freeList_.load() = A

步骤2: 新节点的next指向oldHead
slot->next = A

状态：
slot ──→ A ──→ B ──→ C ──→ nullptr
  ↑
freeList_

步骤3: CAS操作
compare_exchange_weak(freeList_, oldHead, slot)

┌─────────────────────────────────────────────────────────┐
│  CAS: 如果 freeList_ == oldHead (A)                      │
│       则 freeList_ = slot                                │
│       否则失败，重试                                      │
└─────────────────────────────────────────────────────────┘

情况1: CAS成功
freeList_ ──→ slot ──→ A ──→ B ──→ C ──→ nullptr
             ↑
           新表头

情况2: CAS失败（其他线程修改了freeList_）
重试步骤1-3
```

### 5.2 popFreeList CAS流程

```
初始状态：
freeList_ ──→ A ──→ B ──→ C ──→ nullptr

┌───────────────────────────────────────────────────────────┐
│  Thread 1: popFreeList()                                  │
└───────────────────────────────────────────────────────────┘

步骤1: 读取当前头节点
oldHead = freeList_.load() = A

步骤2: 获取下一个节点
newHead = oldHead->next = B

步骤3: CAS操作
compare_exchange_weak(freeList_, oldHead, newHead)

┌─────────────────────────────────────────────────────────┐
│  CAS: 如果 freeList_ == oldHead (A)                      │
│       则 freeList_ = newHead (B)                         │
│       否则失败，重试                                      │
└─────────────────────────────────────────────────────────┘

情况1: CAS成功
freeList_ ──→ B ──→ C ──→ nullptr
             ↑
           新表头

返回: oldHead = A (被删除的节点)

情况2: CAS失败（其他线程修改了freeList_）
重试步骤1-3
```

---

## 六、多线程竞争场景

### 场景1: 两个线程同时push

```
时间线：Thread 1                          Thread 2
        ─────────                         ─────────
        ┌─────────────────────┐
        │ oldHead = A         │
        │ slot1->next = A     │
        └─────────────────────┘
                                          ┌─────────────────────┐
                                          │ oldHead = A         │
                                          │ slot2->next = A     │
                                          └─────────────────────┘
        ┌─────────────────────┐
        │ CAS: freeList_==A?   │
        │ ✓ 成功               │
        │ freeList_ = slot1    │
        └─────────────────────┘
                                          ┌─────────────────────┐
                                          │ CAS: freeList_==A?   │
                                          │ ✗ 失败 (现在是slot1) │
                                          │ 重试...              │
                                          │ oldHead = slot1      │
                                          │ slot2->next = slot1  │
                                          │ CAS: freeList_==slot1?│
                                          │ ✓ 成功               │
                                          │ freeList_ = slot2    │
                                          └─────────────────────┘

最终结果：
freeList_ ──→ slot2 ──→ slot1 ──→ A ──→ B ──→ ...
```

### 场景2: 两个线程同时pop

```
时间线：Thread 1                          Thread 2
        ─────────                         ─────────
        ┌─────────────────────┐
        │ oldHead = A         │
        │ newHead = B          │
        └─────────────────────┘
                                          ┌─────────────────────┐
                                          │ oldHead = A         │
                                          │ newHead = B          │
                                          └─────────────────────┘
        ┌─────────────────────┐
        │ CAS: freeList_==A?   │
        │ ✓ 成功               │
        │ freeList_ = B        │
        │ 返回 A               │
        └─────────────────────┘
                                          ┌─────────────────────┐
                                          │ CAS: freeList_==A?   │
                                          │ ✗ 失败 (现在是B)     │
                                          │ 重试...              │
                                          │ oldHead = B          │
                                          │ newHead = C          │
                                          │ CAS: freeList_==B?   │
                                          │ ✓ 成功               │
                                          │ freeList_ = C        │
                                          │ 返回 B               │
                                          └─────────────────────┘

最终结果：
freeList_ ──→ C ──→ D ──→ ...
Thread 1 获得 A
Thread 2 获得 B
```

### 场景3: 一个push，一个pop

```
初始状态：freeList_ ──→ A ──→ B ──→ C ──→ nullptr

时间线：Thread 1 (push)                   Thread 2 (pop)
        ───────────────                   ────────────
        ┌─────────────────────┐
        │ oldHead = A         │
        │ slot->next = A      │
        └─────────────────────┘
                                          ┌─────────────────────┐
                                          │ oldHead = A         │
                                          │ newHead = B          │
                                          └─────────────────────┘
        ┌─────────────────────┐
        │ CAS: freeList_==A?   │
        │ ✓ 成功               │
        │ freeList_ = slot     │
        └─────────────────────┘
                                          ┌─────────────────────┐
                                          │ CAS: freeList_==A?   │
                                          │ ✗ 失败 (现在是slot)   │
                                          │ 重试...              │
                                          │ oldHead = slot       │
                                          │ newHead = A          │
                                          │ CAS: freeList_==slot? │
                                          │ ✓ 成功               │
                                          │ freeList_ = A        │
                                          │ 返回 slot            │
                                          └─────────────────────┘

最终结果：
freeList_ ──→ A ──→ B ──→ C ──→ nullptr
Thread 2 获得 slot (刚被push的节点)
```

---

## 七、CAS vs 互斥锁对比

### 7.1 CAS版本（之前）

```
优点：
  ✓ 理论上无锁，性能更高
  ✓ 避免线程阻塞
  ✓ 适合高并发场景

缺点：
  ✗ 代码复杂，容易出错
  ✗ ABA问题（虽然在这个场景风险较低）
  ✗ CAS失败需要自旋重试，CPU占用高
  ✗ 内存顺序参数复杂（acquire/release/relaxed）
```

### 7.2 互斥锁版本（当前）

```
优点：
  ✓ 代码简单，易于理解
  ✓ 避免ABA问题
  ✓ 不会自旋，失败直接阻塞
  ✓ 调试更容易

缺点：
  ✗ 有锁，理论性能略低
  ✗ 线程会被阻塞
  ✗ 锁竞争严重时性能下降
```

---

## 八、性能数据

### 单线程测试
```
操作次数: 100,000
内存大小: 32字节

Memory Pool:  2.445 ms
New/Delete:   8.865 ms

性能提升: 3.6倍
```

### 多线程测试 (4线程)
```
操作次数: 100,000 (每线程25,000)
内存大小: 32字节

Memory Pool:  7.837 ms
New/Delete:   10.399 ms

性能提升: 1.3倍
```

### 多线程性能瓶颈分析
```
V1单线程: 快65%
V1多线程: 慢4倍

原因：
  1. mutexForFreeList_锁竞争严重
  2. CAS版本自旋重试消耗CPU
  3. 所有线程共享同一个freeList_
  4. 缓存行伪共享问题

解决方案 (V2/V3):
  ✓ ThreadCache: 每个线程独立缓存
  ✓ CentralCache: 批量分配减少锁竞争
  ✓ PageCache: 页级缓存减少系统调用
```

---

## 九、总结

### V1核心特点
1. **64个定长内存池**: 8字节到512字节，8字节递增
2. **哈希映射**: O(1)时间复杂度找到对应内存池
3. **无锁自由链表**: 使用CAS原子操作（之前）/ 互斥锁（当前）
4. **双重锁保护**: mutexForBlock_ + mutexForFreeList_
5. **O(1)分配**: 直接操作链表头节点

### 适用场景
✓ 单线程环境（性能优秀）
✓ 低并发场景（性能可接受）
✓ 学习内存池原理（代码简单易懂）

### 不适用场景
✗ 高并发多线程（性能差）
✗ 需要大内存分配（>512字节直接用new）
✗ 对内存利用率要求极高（定长分配有浪费）

### 演进方向
V1 → V2/V3: 从单一内存池到三级缓存架构
  - ThreadCache: 线程级私有缓存
  - CentralCache: 全局共享缓存
  - PageCache: 页级缓存